import numpy as np
while True:
    while True:
        try:
            # Вводимо розмірності першої та другої матриць
            n, m = int(input('Кількість рядків 1 матриці: ')), \
                   int(input('Кількість стовчиків 2 матриці: '))
            k, l = int(input('Кількість рядків 2 матриці: ')), \
                   int(input('Кількість стовпчиків 2 матриці: '))
            A, B = np.zeros((n, m), dtype=int), np.zeros((k, l), dtype=int)  # Ініціалізація двох матриць нулями.
            for i in range(n):
                for j in range(m):
                    # Перевірка на правильність розмірності 3 на 3
                    if n == 3 and m == 3 and k == 3 and l == 3:
                        # Користувач заповнює матрицю
                        A[i, j] = int(input(F' A([{i + 1}, {j + 1}]): '))
                        B[i, j] = int(input(F' B([{i + 1}, {j + 1}]): '))
                    # Якщо розмірність матриці НЕ 3 на 3
                    elif n != 3 or m != 3 and k != 3 or l != 3:
                        print('Розмірність НЕ 3 на 3 ')
                    elif n > 3 or m > 3 and k > 3 or l > 3:
                        print('Розмірність НЕ 3 на 3')
            break
        except ValueError:  # Перевірка на правильність вводу(числа)
            print('Введіть числа! ')
    N = np.zeros((k, l), dtype=int)  # Ініціалізуємо матрицю нулями.Дана матриця буде результатом множення двох матриць,
    # заданих користувачем
    F = 0  # Тимчасова змінна, яка буде результатом множення стовпчика на рядок.
    # Трансортуємо порожню матрицю,так можна перемножати рядок першої матриці на рядок другої,а не рядок першої матриці на
    # стовпчик другої. Результат буде той самий
    T = np.zeros((k, l), dtype=int)
    # Ще раз отримаємо доступ до кожного елемента матриць. Але тут ми використовуємо цикл для елементів рядка першої
    # матриці та стопчика другої матриці.
    for i in range(n):
        for j in range(l):
            # Транспонуємо матрицю В
            T[i, j] = B[j, i]
            F = A[i - 2] * T[i - 2]  # Змінна для добутку РЯДКА на РЯДОК
            # Заповнюємо комірки нової матриці
            # Перший рядок матриці N
            N[0, 0] = F[i - 2] + F[i - 1] + F[i]
            F = A[i - 2] * T[i - 1]
            N[0, 1] = F[i - 2] + F[i - 1] + F[i]
            F = A[i - 2] * T[i]
            N[0, 2] = F[i - 2] + F[i - 1] + F[i]
            F = A[i - 1] * T[i - 2]
            # Другий рядок матриці N.
            N[1, 0] = F[i - 2] + F[i - 1] + F[i]
            F = A[i - 1] * T[i - 1]
            N[1, 1] = F[i - 2] + F[i - 1] + F[i]
            F = A[i - 1] * T[i]
            N[1, 2] = F[i - 2] + F[i - 1] + F[i]
            F = A[i] * T[i - 2]
            # Третій рядок матриці N.
            N[2, 0] = F[i - 2] + F[i - 1] + F[i]
            F = A[i] * T[i - 1]
            N[2, 1] = F[i - 2] + F[i - 1] + F[i]
            F = A[i] * T[i]
            N[2, 2] = F[i - 2] + F[i - 1] + F[i]
            print('Результат добутку: ', N)

